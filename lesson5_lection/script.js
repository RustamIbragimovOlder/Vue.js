// Введение
// Если приложение плохо спроектировано, работать с ним становится тяжело. Когда всё приложение описано в одном файле, в нём становится очень сложно разобраться, а кроме того, разные части приложения могут взаимодействовать непредсказуемо и неконтролируемо. Например, одноименные переменные могут оказаться в одной области видимости и перекрывать друг друга.
// Для того, чтобы приложение было легче расширять и поддерживать, его принято делить на компоненты – отдельные независимые части. Нечто похожее реализовано в парадигме ООП, но многие отказываются именно от объектного подхода, так как наглядность в данной ситуации минимальная.Поэтому нам необходимо решить эту задачу плюс оставить наглядность и удобство использования или переиспользования частей кода, для этого как раз и существуют компоненты. В каждом серьезном фреймворке, в том числе и Vue.js, есть инструменты для реализации компонентного подхода.

// Создание компонент

// Теперь объявим новый компонент. Для этого у Vue есть метод component(). Этот метод принимает два аргумента: название компонента и объект с настройками:
// Vue.component('some', {});
// Название может быть любым, но если оно состоит из нескольких слов, их принято разделять дефисом:
// Vue.component('some-component', {});
// Главный параметр компонента – template, html-разметка. Напишем что-нибудь простое:
Vue.component('some-component', {
    template: '<h1>Hi Component!</h1>'
});
const app = new Vue({
    el: '#app',
    data: {
    }
})
// Теперь мы можем вызвать компонент в основном файле с разметкой: (смотри index.html)
// То есть Vue подставляет компонент туда, где его вызвали.Компонент можно использовать несколько раз.

// Ограничения шаблона
// Важно помнить, что шаблон может содержать только один внешний элемент. Будем идти от обратного, рассмотрим простую ситуацию, когда необходимо добавить 2 параграфа:
Vue.component('some', {
    template: `
    <div>
        <p></p>
        <p></p>
    </div>
    `,
});
Vue.component('article-website', {
    template: `
    <article>
        <h3>New article</h3>
        <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Nihil obcaecati repellat dolorum commodi aspernatur molestias esse cupiditate eius adipisci illo velit, dignissimos, optio ipsa nesciunt aliquid nemo nam minima id?</p>
    </article>
    `
});
const app1 = new Vue({ el: '#app1' })
// Теперь давайте представим что на нашем сайте несколько разделов статей и получается что внутри такого раздела сайта может быть несколько статей, получается нам необходимо создавать компонент, который будет содержать в себе другие компоненты. Конечно мы можем встретить такую ситуацию и компоненты легко можно разместить внутри другого
Vue.component('section-website', {
    template: `
        <section>
            <h2>New section</h2>
            <article-website></article-website>
            <article-website></article-website>
        </section>
        `,
});
Vue.component('article-website', {
    template: `
        <article>
            <h2>New article</h2>
            <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Nihil obcaecati repellat dolorum commodi aspernatur molestias esse cupiditate eius adipisci illo velit, dignissimos, optio ipsa nesciunt aliquid nemo nam minima id?</p>
        </article>
        `
});
const app2 = new Vue({ el: '#app2' })
// Теперь на странице может быть несколько разделов сайта и если нам нужно будет переиспользовать компонент, то мы сразу получаем готовое решение. Конечно использование компонентов это отлично, но какую проблему мы успеваем заметить, конечно же это то что при дублировании компонента статей, его содержимое не меняется, да и заголовок наших секций будет неизменным, получается что нам не хватает проброса содержимого внутри компонента

// Проброс содержимого
// Содержимое, которое находится между открывающим и закрывающим тегами компонента, можно пробрасывать внутрь и подставлять в шаблон. Для подстановки содержимого используется тег <slot>:
Vue.component('some-component', {
    template: '<h2><slot></slot></h2>'
});
// Конечно данный подход не кажется самым рациональным, но мы начинаем от самого простого и переходим к более сложному

// Работа с данными
// В компонентах данные тоже хранятся в поле data, но здесь это не объект, а функция, возвращающая объект:
Vue.component('some-component', {
    template: '<h2></h2>',
    data() {
        return {
            name: 'Frodo',
        };
    },
});
// Имя можно подставить в шаблон компонента, используя mustache-синтаксис (усатый синтаксис):
Vue.component('some-component', {
    template: '<h2>{{ name }}</h2>',
    data() {
        return {
            name: 'Frodo',
        };
    },
});

// Передача свойств
// В компоненты можно передавать данные извне с помощью свойств. Это значения, которые устанавливаются во время вызова компонента и которые можно использовать для преобразования и подстановки в шаблон. Вернёмся к примеру выше:
Vue.component('some-component', {
    template: '<h2>{{ name }}</h2>',
    data() {
        return {
            name: 'Frodo',
        };
    },
});
// Удалим из него поле data:
Vue.component('some-component', {
    template: '<h1>{{ name }}</h1>'
});
// Сейчас переменной name не существует, поэтому компонент выдаст ошибку. Объявим name как свойство при вызове компонента: (смотри index.html)
// Но компонент будет выдавать ошибку и теперь. Свойство нужно объявить внутри компонента в поле props. В это поле передается массив с именами всех свойств:
Vue.component('some-component', {
    props: ['name'],
    template: '<h2>{{ name }}</h2>',
});
// Теперь значение свойства name будет подставляться в шаблон. Если нужно пробросить не конкретное значение, а содержимое переменной, то это можно сделать через конструкцию v-bind. Например, в основном хранилище данных нашего приложения есть переменная name:
const app5 = new Vue({
    el: '#app5',
    data: {
        name: 'Frodo'
    }
})
// Как итог, мы можем передавать любой контент с помощью тега <slot> что оказалось не очень удобным, более правильный подход это в сам компонент передать значение в props и переиспользовать его с помощью “усатого синтаксиса”, ну и конечно мы можем использовать значения в переменных через v-bind

// ПРАКТИКА
new Vue({
    el: '#pract1',
    data: {
        articles: ['info article1', 'info article2', 'info article3', 'info article4'],
        nameButtons: ['one', 'two', 'three'],
        currentTab: 'one',
    },
    methods: {
        newInfo() {
            console.log('hello methods');
        },
    },
    computed: {
        newComp() {
            return this.message;
        },
        changeTabs() {
            return `change-${this.currentTab}`;
        }
    }
})